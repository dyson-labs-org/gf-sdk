import { parse } from "dotenv";
import { readFile, writeFile } from "node:fs/promises";
import { existsSync } from "node:fs";
import { createInterface } from "node:readline/promises";
import type { Interface } from "node:readline/promises";
import { stdin as input, stdout as output } from "node:process";

type Network = "testnet" | "mainnet";

const NETWORKS: Network[] = ["testnet", "mainnet"];

const DEFAULT_URL: Record<Network, string> = {
  testnet: "https://testnet-btcpay.dyson-labs.com",
  mainnet: "https://btcpay.dyson-labs.com"
};

interface EnvValues {
  BTCPAY_URL: string;
  BTCPAY_API_KEY: string;
  STORE_ID: string;
}

async function run() {
  const rl = createInterface({ input, output });

  const configs: Record<Network, EnvValues> = {
    testnet: await collectEnv(rl, "testnet"),
    mainnet: await collectEnv(rl, "mainnet")
  };

  for (const network of NETWORKS) {
    await writeEnvFile(network, configs[network]);
  }

  const activeNetwork = await pickActiveNetwork(rl);

  await rl.close();

  if (activeNetwork) {
    await writeActiveEnv(activeNetwork, configs[activeNetwork]);
    console.log(`\nCreated .env for ${activeNetwork}.`);
  }

  console.log("\nEnvironment configuration complete.");
}

async function collectEnv(rl: Interface, network: Network) {
  console.log(`\n${network.toUpperCase()} configuration`);

  const existing = await loadExistingEnv(network);

  const btcpayUrl = await prompt(
    rl,
    `BTCPAY_URL [${existing.BTCPAY_URL ?? DEFAULT_URL[network]}]: `,
    existing.BTCPAY_URL ?? DEFAULT_URL[network]
  );

  const apiKey = await prompt(rl, "BTCPAY_API_KEY: ", existing.BTCPAY_API_KEY);
  const storeId = await prompt(rl, "STORE_ID: ", existing.STORE_ID);

  return {
    BTCPAY_URL: btcpayUrl,
    BTCPAY_API_KEY: apiKey,
    STORE_ID: storeId
  } satisfies EnvValues;
}

async function prompt(rl: Interface, message: string, defaultValue?: string) {
  while (true) {
    const answer = (await rl.question(message)).trim();

    if (!answer && defaultValue) {
      return defaultValue;
    }

    if (!answer) {
      console.log("Value required. Please try again.");
      continue;
    }

    return answer;
  }
}

async function loadExistingEnv(network: Network) {
  const filename = envFilename(network);

  if (!existsSync(filename)) {
    return {} as Partial<EnvValues>;
  }

  const contents = await readFile(filename, "utf8");
  return parse(contents) as Partial<EnvValues>;
}

async function writeEnvFile(network: Network, values: EnvValues) {
  const filename = envFilename(network);
  const header = `# ${network} configuration generated by npm run configure-env`;
  const body = serializeEnv({ NETWORK: network, ...values });
  await writeFile(filename, `${header}\n${body}`);
  console.log(`Saved ${filename}`);
}

async function writeActiveEnv(network: Network, values: EnvValues) {
  const header = `# Active environment (${network}) generated by npm run configure-env`;
  const body = serializeEnv({ NETWORK: network, ...values });
  await writeFile(".env", `${header}\n${body}`);
}

function serializeEnv(values: Record<string, string>) {
  return Object.entries(values)
    .map(([key, value]) => `${key}=${formatEnvValue(value)}`)
    .join("\n")
    .concat("\n");
}

function formatEnvValue(value: string) {
  if (/^[A-Za-z0-9_.:-]+$/.test(value)) {
    return value;
  }

  return JSON.stringify(value);
}

function envFilename(network: Network) {
  return `.env.${network}`;
}

async function pickActiveNetwork(rl: Interface) {
  const answer = (await rl.question("\nSet active environment? (testnet/mainnet/skip): ")).trim().toLowerCase();

  if (answer === "skip" || answer === "") {
    return undefined;
  }

  if (answer === "testnet" || answer === "mainnet") {
    return answer as Network;
  }

  console.log("Unknown option. Skipping .env generation.");
  return undefined;
}

run().catch((error) => {
  console.error("Failed to configure environments:", error.message);
  process.exit(1);
});
